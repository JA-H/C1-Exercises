// Implementation of SparseMatrix class.

#include "SparseMatrix.hh"

/* The SparseMatrix constructor takes four parameters, the number of rows, the number of columns, a vector containing vectors of nonzero values of the matrix for 
 * each row, and vector of vectors containing the column number for each of the nonzero values. To ensure zero rows are included, we resize the values and column_position
 * vectors to have M elements (so zero rows are represented by empty vectors).
 * 
 * 
 * We store sparse matrices as two vectors of vectors, one of doubles representing the nonzero entries of of each row, and the 
 * other of integers representing which columns the entries of a given row belong. 
 *  
 * For example, the matrix
 * 
 * 	[-1.0, 0.0, 0.0]
 * A =	[ 2.3, 3.6, 6.6]
 * 	[ 0.0, 2.3, 3.0]
 * 	[ 0.0, 0.0, 0.0]
 * 
 * can be represented stored as follows:
 * M 			= 4
 * N			= 3
 * values		=	{ {-1.0}, {2.3, 3.6, 6.6}, {2.3, 3.0}, {} }
 * column_position	=	{ {1}, {1, 2, 3}, {2,3}, {} }.
 * 
 */

//Default Constructor
SparseMatrix::SparseMatrix()
  : M_  ( 0 ), N_ ( 0 )
{
}



//Constructor
SparseMatrix::SparseMatrix( unsigned int M, 
			    unsigned int N, 
			    std::vector< std::vector<double> > values, 
			    std::vector< std::vector<unsigned int> > column_position )
  : M_ ( M ), N_ ( N ), values_ ( values ), column_position_ ( column_position )
{
  values_.resize(M_);
  column_position_.resize(M_);
}

//Copy Constructor
SparseMatrix::SparseMatrix( const SparseMatrix& source )
  : M_ ( source.M_ ), N_ ( source.N_ ), values_ ( source.values_ ), column_position_ ( source.column_position_ )
{
}

//Destructor
SparseMatrix::~SparseMatrix()
{
}







/* The add_entry function takes the row and column positions and adds the value of the matrix at the position to the ith element
 * of the "values" vector and the column position to the ith element of the "comlumn_position" vector.
 */

void SparseMatrix::add_entry( unsigned int i, unsigned int j, double a_ij ) 
{ 
    // We check the values of i and j are valid.
    if(i >= M_ || j >= N_ )
    {
      std::cout << "Invalid indices." << std::endl;
    }
    
    i_ = i;
    j_ = j;
    a_ij_ = a_ij;
    
    
    for( std::vector<unsigned int>::iterator column_it = column_position_[i_].begin(); column_it < column_position_[i_].end(); ++column_it )
    {
      if(j_ == *column_it)
      {
	std::cout << "Value already defined." << std::endl;
      }
    }
    
    if(a_ij_ != 0.0)
    {
      column_position_[i_].push_back(j_);
      values_[i_].push_back(a_ij_);
    }
   
    std::sort(values_[i_].begin(), values_[i_].end() );
    std::sort(column_position_[i_].begin(), column_position_[i_].end() );
}

//double SparseMatrix::get_entry(unsigned int i, unsigned int j)
//{  
//  assert(i < M_ && j < N_);
//   i_ = i;
//   j_ = j;
//  
//  double a_ij;
//  
//  for(std::vector<unsigned int>::iterator column_it = column_position_[i_].begin(); column_it != column_position_[i_].end(); ++column_it)
//  {
//    int k = 0;
//    if(j_ == *column_it)
//    {
//      return values_[i][k];
//    }
//    else
//    {
//      ++k;
//    }
//  }
//}

std::vector<double> SparseMatrix::GaussSeidel( std::vector<double> b )
{
  b.resize(M_);
  
  std::vector<double> x;
  x.resize(M_);
  
  return x;
}













